n, k = list(map(int, input().split()))
a = list(map(int, input().split()))
"""
Эх, был бы у нас список idx, который для каждого дерева содержал
индекс первого же встреченного дерева того же цвета, расположенного
правее! Ну или недопустимый индекс n, если такого дерева мы не встретили.
Давайте построим такой список.
Одновременно строим список frst индексов тех деревьев, цвет которых
встречается в ряду первый раз. Он понадобится нам для построения первого
допустимого отрезка.
"""
s = [(a[i],i) for i in range(n)]
s.sort()
idx = [0]*n
frst = [n]*k
frst[s[0][0]-1] = s[0][1]
for i in range(n-1):
    if s[i+1][0] == s[i][0]:
        idx[s[i][1]] = s[i+1][1]
    else:
        idx[s[i][1]] = n
        frst[s[i+1][0]-1] = s[i+1][1]
idx[s[n-1][1]] = n
"""
Берем начальный отрезок, содержащий все цвета, и его длину.
И начинаем от него просмотр массива направо в поисках минимальной длины
"""
i1 = 0
maxlen = max(frst)+1
i2 = maxlen
while idx[i1] < i2: i1 += 1
mi1 = i1
mi2 = i2
maxlen = i2-i1
 # Теперь ищем
while idx[i1] != n:
    i2 = idx[i1]+1
    while idx[i1] < i2: i1 += 1
    if i2-i1 < maxlen:
        mi1 = i1
        mi2 = i2
        maxlen = i2-i1
# Ответ
print(mi1+1, mi2)
